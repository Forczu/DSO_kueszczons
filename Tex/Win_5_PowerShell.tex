%\item \question{}%
%{Tak}{}%
%{Nie}{}%
%{}{}%
%{}{}

% !TeX spellcheck = pl_PL

% *************************************************************
% --- Sprawdzić poprawność Children oraz ChildItem
% *************************************************************
\newpage
\section{Interpreter poleceń PowerShell}
	\begin{enumerate}
		\item \question{Polecenie$>$ get-childitem C:\textbackslash test\textbackslash * -include *.txt -recurse $ \mid $ remove-item}%
		{Tak}{Znajduje i usuwa wszystkie pliki z rozszerzeniem .txt z folderu "C:\textbackslash test" i podfolderów.}%
		{Nie}{Znajduje i usuwa wszystkie pliki z rozszerzeniem .txt z folderu "C:\textbackslash test", bez podfolderów.}%
		{Nie}{Znajduje i wypisuje wszystkie pliki z rozszerzeniem .txt z folderu "C:\textbackslash test", bez podfolderów.}%
		{Nie}{Jest niepoprawne}
		\item \question{Które wersje systemu Windows NIE wpierają PowerShella?}%
		{Tak}{Windows 2000 SP4}%
		{Tak}{Windows 2000}%
		{Nie}{Windows Server 2008}%
		{Nie}{Windows 7}
		\item \question{Które polityki wykonywania skryptów w PowerShell zabraniają wykonywania skryptów pochodzących z lokalnego komputera, jeśli skrypty te nie są podpisane przez zaufanego wydawcę?}%
		{Tak}{Restricted}%
		{Tak}{AllSigned}%
		{Nie}{RemoteSigned}%
		{Nie}{Unrestricted}
		\item \question{Po wykonaniu poniższego skryptu w PowerShell\\
			\$przedmiot = "DSO" if (\$przedmiot -eq "DSO") \{"Dedykowane Systemy Operacyjne"\} elseif (\$przedmiot -eq "PK") \{"Programowanie Komputerów"\} else \{"Nieznany przedmiot"\}}%
		{Nie}{Na ekranie zostanie wyświetlony napis "Nieznany przedmiot".}%
		{Tak}{Wartość zmiennej \$przedmiot nie ulegnie zmianie.}%
		{Nie}{Na ekranie pojawi się komunikat o błędzie składniowym.}%
		{Nie}{Do zmiennej \$przedmiot zostanie przypisana wartość "Dedykowane Systemy Operacyjne".}
		\item \question{Aby zwrócić wszystkie obiekty w bieżącej lokalizacji nalezy użyć polecenia:}%
		{Tak}{Get-children}%
		{Nie}{Copy-item}%
		{Nie}{Get-content}%
		{Nie}{Get-process}
		\item \question{Polecenie "PS$>$ get-process d* $ \mid $ stop-process"}%
		{Tak}{poszczególne polecenia należą do tzw. poleceń Cmdlet. (należy do poleceń Cmdlet - inna odpowiedź) }%
		{Nie}{zatrzymuje wszystkie uruchomione procesy.}%
		{Nie}{zatrzymuje wszystkie procesy działające na partycji D.}%
		{Tak}{zatrzymuje wszystkie procesy których nazwa rozpoczyna się literą "d".}
		
		\newpage
		\item \question{Aby zwrócić wszystkie obiekty w bieżącej lokalizacji należy użyc polecenia:}%
		{Nie}{Get-process}%
		{Nie}{Copy-item}%
		{Nie}{Get-content}%
		{Tak}{Get-children}
		\item \question{Zaznacz poprawne przyporządkowania aliasów do Cmdletów}%
		{Nie}{taskkill -$>$ Kill-Process}%
		{Tak}{ls -$>$ Get-ChildItem}%
		{Tak}{help -$>$ Get-Help}%
		{Tak}{man -$>$ Get-Help}
		\item \question{Polecenie Get-EventLog w Windows PowerShell pozwala:}%
		{Nie}{Zapisywać informacje do dziennika zdarzeń.}%
		{Nie}{Takie polecenie nie istnieje.}%
		{Tak}{Pobierać wpisy z dziennika zdarzeń.}%
		{Nie}{Pobierać wpisy z pliku C:\textbackslash Var\textbackslash Log\textbackslash Messages.}
		\item \question{Polecenia natywne dla Windows PowerShell, które pozwalają na wykonywanie podstawowych operacji na obiektach w środowisku WPS to:}%
		{Nie}{Potoki (pipelines)}%
		{Tak}{Aplety poleceń (cmdlets)}%
		{Nie}{Aplety skryptowe (scriptlets)}%
		{Nie}{Komendy linii poleceń (line commands)}
		\item \question{Wskaż wszystkie poprawne zdania dotyczące interpretera Windows PowerShell:}%
		{Tak}{PowerShell jest oparty o .NET}%
		{Nie}{PowerShell nie udostępnia mechanizmów potoku.}%
		{Tak}{PowerShell pozwala ustawić różne polityki kontrolujące jakie skrypty można uruchomić.}%
		{Nie}{PowerShell jest kompatybilny z bashem.}
		\item \question{Polityka Restricted wykonywania plików:}%
		{Tak}{Jest domyślną polityką w środowisku PowerShell.}%
		{Nie}{Pozwala na uruchamianie skryptów z rozszerzeniem .ps1.}%
		{Nie}{Nie pozwala na wykonywanie komend w oknie interpretera.}%
		{Nie}{Pozwala na uruchamianie skryptów z rozszerzeniem .ps1xml.}
		\item \question{Które polecenie wypisze zawartość bieżącego katalogu z pominięciem plików o rozszerzeniu .exe?}%
		{Nie}{Dir *.exe}%
		{Tak}{gci -exclude *.exe}%
		{Tak}{Get-Childitem -exclude *.exe}%
		{Nie}{ls -include *.exe}
		
		\newpage
		\item \question{Wskaż poprawne polecenia PowerShell usuwające z bieżącego katalogu pliki większe niż 2kB:}%
		{Nie}{Get-Childitem $ \mid $  Where-Object ( \$\_.length $>$ 2kB ) $ \mid $ Remove-Item}%
		{Nie}{Get-Childitem $ \mid $ Remove-Item $ \mid $ Where ( \$\_.length $>$ 2kB )}%
		{Tak}{Get-Childitem $ \mid $ Where-Object ( \$\_.length -gt 2kB ) $ \mid $ Remove-Item}%
		{Tak}{ls $ \mid $ where-object \{ \$\_.length -gt 2kB \} $ \mid $ rm}
		\item \question{Polecenie\\ "PS$ > $ get-process $ \mid $ where-object { \$\_.WS -gt 300MB } $ \mid $ stop-process"\\ wydane w interpreterze Windows PowerShell:}%
		{Nie}{Listuje procesy, które zużywają więcej niż 300 MB.}%
		{Nie}{Szuka procesu, który zużywa więcej niż 300 MB i wyświetla nazwę.}%
		{Tak}{Szuka procesu, który zużywa więcej niż 300 MB i zatrzymuje go.}%
		{Nie}{Szuka procesu, który zużywa mniej niż 300 MB i zatrzymuje go.}
		\item \question{Która z wersji systemu Windows obsługuje interpreter PowerShell?}%
		{Tak}{Windows Vista}%
		{Tak}{Windows 7}%
		{Tak}{Windows XP SP2/SP3}%
		{Nie}{Windows 95}
		\item \question{Polecenie Set-Location w Cmdlets (PowerShell) ma swój odpowiednik w interpreterze komend cmd.exe. Jest to:}%
		{Tak}{chdir}%
		{Nie}{set}%
		{Nie}{sloc}%
		{Tak}{cd}
		\item \question{Które z poleceń są poprawnymi podstawowymi aliasami w Windows PowerShell, służącymi do czyszczenia ekranu?}%\textsl{}
		{Nie}{Clear-Console}%
		{Nie}{Clear-Host}%
		{Tak}{clear}%
		{Tak}{cls}
		\item \question{W celu zatrzymania procesów zużywających więcej niż 100MB pamięci RAM należy użyć polecenia:}%
		{Nie}{PS$ > $ stop-process $ \mid $ where-object \{ \$\_.WS -gt 100MB \}}%
		{Nie}{PS$ > $ stop-process \$Memory -gt 100MB}%
		{Nie}{PS$ > $ get-process $ \mid $ where-object \{ \$Memory -gt 100MB \} $ \mid $ stop-process}%
		{Tak}{PS$ > $ get-process $ \mid $ where-object \{ \$\_.WS -gt 100MB \} $ \mid $ stop-process}
		
		\newpage
		\item \question{Zaznacz poprawne zdania dotyczące powłoski PowerShell:}%
		{Tak}{Wszystkie zmienne są obiektami .NET.}%
		{Tak}{Do zmiennych odwołuje się używając znaku \$.}%
		{Nie}{Część zmiennych jest obiektami .NET.}%
		{Nie}{Do zmiennych odwołuje się używając znaku \#.}
		\item \question{Za pomocą polecenia:\\Get-Childitem C:\textbackslash Work\textbackslash  -Recurse -Force $ \mid $ Measure-Object -property length -sum\\(Komentarz: polecenie measure-object służy do generowania statystyk)}%
		{Tak}{Znajdziemy liczbę plików i ich całkowity rozmiar w folderze C:\textbackslash Work oraz w podfolderach.}%
		{Nie}{Wypiszemy zawartość folderu C:\textbackslash Work.}%
		{Nie}{Wypiszemy największy plik z folderu C:\textbackslash Work.}%
		{Nie}{Jest to niepoprawna składnia.}
		\item \question{Aby usunąć wszystkie pliki z katalogu c:\textbackslash temp\textbackslash o rozszerzeniu .xls w Windows PowerShell należy użyć polecenia:}%
		{Tak}{remove-item c:\textbackslash temp\textbackslash *.xls}%
		{Tak}{get-childitem c:\textbackslash temp\textbackslash *.xls $ \mid $ foreach-object \{ remove-item \$\_.fullname \}}%
		{Nie}{remove-item c:\textbackslash temp\textbackslash * -exclude *.xls}%
		{Nie}{remove-file c:\textbackslash temp\textbackslash * -extension xls}
		\item \question{Polecenie:\\PS$ > $ get-childitem C:\textbackslash test\textbackslash * -include *.txt -recurse $ \mid $ remove-item }%
		{Tak}{Znajduje i usuwa wszystkie pliki z rozszerzeniem .txt z folderu "C:\textbackslash test" i podfolderów}%
		{Nie}{Znajduje i usuwa wszystkie pliki z rozszerzeniem .txt z folderu "C:\textbackslash test", bez podfolderów}%
		{Nie}{Znajduje i wypisuje wszystkie pliki z rozszerzeniem .txt z folderu "C:\textbackslash test", bez podfolderów}%
		{Nie}{Jest niepoprawne.}
		\item \question{Jakie rozszerzenia mogą mieć skrypty PowerShell?}%
		{Nie}{.wps}%
		{Nie}{.shl}%
		{Nie}{.cmd}%
		{Tak}{.ps1}
		\item \question{Której z niżej wymienionych polityk uruchamiania skryptów są dostępne w powerShell systemu Windows?}%
		{Nie}{NoneAllowed - nie pozwala na uruchamianie żadnych skryptów.}%
		{Tak}{AllSigned - możliwość uruchomienia tylko podpisanych skryptów.}%
		{Tak}{RemoteSigned - możliwość uruchamiania skryptów lokalnych oraz podpisanych pochodzących z Internetu.}%
		{Tak}{Unrestricted - pozwala na uruchamianie wszystkich skryptów.}
		
		\newpage
		\item \question{Czym charakteryzują się komendy (tzw. cmdlety) w PowerShell?}%
		{Tak}{Zazwyczaj zwracają obiekty.}%
		{Nie}{Nie mogą mieć zdefiniowanych kilku aliasów jednocześnie.}%
		{Nie}{Mają nazwy postaci "rzeczownik-czasownik"}%
		{Tak}{Mają nazwy postaci "czasownik-rzeczownik"}
		\item \question{Aby uzyskać pomoc na temat poleceń w Windows PowerShell należy użyć polecenia:}%
		{Nie}{please}%
		{Tak}{help}%
		{Nie}{Oh genie}%
		{Tak}{Get-Help}
		\item \question{Aby sprawdzić czy jakiś katalog już istnieje w Windows PowerShell można skorzystac z poleceń:}%
		{Nie}{remove-item}%
		{Tak}{test-path}%
		{Nie}{path}%
		{Nie}{new-item}
		\item \question{Wskaż wszystkie prawdziwe zdania dotyczące interpretera Windows PowerShell:}%
		{Tak}{Polecenie ls jest aliasem polecenia Get-Children.}%
		{Nie}{PowerShell nie posiada modułów i przystawek pozwalających na rozszerzanie powłoki poprzez dodawanie nowych cmdletów.}%
		{Nie}{W systemie operacyjnym Windows XP SP2 domyślnie zainstalowaną wersją PowerShella jest wersja "PowerShell v2"}%
		{Tak}{PowerShell pozwala na przetwarzanie potokowe, które pozwala na przekazywanie obiektu z jednego cmdletu do drugiego, bez potrzeby korzystania z parsowania tekstu czy zmiany formatowania.}
		\item \question{Polecenie:
			"new-item c:\textbackslash temp\textbackslash test -type directory"\\
			spowoduje:}%
		{Nie}{Utworzenie katalogu directory w katalogu c:\textbackslash temp\textbackslash test}%
		{Nie}{Sprawdzi istnienie katalogu test w katalogu c:\textbackslash temp}%
		{Tak}{Utworzenie katalogu test w katalogu c:\textbackslash temp}%
		{Nie}{Sprawdzi czy "test" w katalogu c:\textbackslash temp jest katalogiem}
		\item \question{Które wersje systemu Windows NIE wspierają PowerShella?}%
		{Nie}{Windows Vista}%
		{Tak}{Windows 2000}%
		{Nie}{Windows XP SP2}%
		{Nie}{Windows 7}
		
		\newpage
		\item \question{Które wersje systemu Windows NIE wspierają PowerShella?}%
		{Tak}{Windows 2000}%
		{Tak}{Windows 2000 SP4}
		{Nie}{Windows Server 2008}%
		{Nie}{Windows 7}%
		\item \question{Wskaż wszystkie prawdziwe zdania dotyczące interpretera Windows PowerShell:}%
		{Tak}{Wszystkie zmienne są obiektami .NET.}%
		{Tak}{Aby skopiować plik należy wpisać polecenie "Copy-item lokalizacja1 lokalizacja2"}%
		{Nie}{Aby skopiować plik należy wpisać polecenie "Set-Location lokalizacja1 lokalizacja2"}%
		{Tak}{PowerShell jest elementem pakietu Windows Management Framework.}
		\item \question{W Windows PowerShell poprawnie stworzona pętla to:}%
		{Tak}{ \$a = 1 do \{ \$a; \$a++ \} while (\$a -lt 10) }%
		{Nie}{ \$a = 10 do \{ \$a; \$a$ -- $ \} while (\$a -lt 3) }%
		{Tak}{ for (\$a = 1; \$a -le 10; \$a++) \{ \$a \} }%
		{Nie}{ foreach ( \$i in get-child c:\textbackslash scripts ) \{\$i.extended\} }
		\item \question{Co należy wstawić w miejsce znaków zapytania, aby poniższy skrypt PowerShella wyświetlał nazwę procesu w danej chwili najbardziej obciążającego procesor?\\
			\$ps = get-process\\
			\$max = \$ps[0]\\
			foreach (\$p in \$ps )\\
			\{\\
				if ( ??? )\\
				\{ \$max = \$p \}
			\}\\
			\$max.processname
			}%
		{Nie}{ \$p $ > $ \$max }%
		{Tak}{ \$p.cpu -gt \$max.cpu }%
		{Nie}{Brak odpowiedzi w źródle.}%
		{Nie}{Brak odpowiedzi w źródle.}
		\item \question{Aby wyświetlić wszystkie pliki o rozszerzeniu .txt znajdujące się w obecnym katalogu można użyć polecenia:}%
		{Tak}{Get-ChildItem *.* -include *.txt}%
		{Nie}{Get-ChildItem -extension *.txt}%
		{Nie}{Get-ChildItem -exclude *.txt}%
		{Tak}{Get-ChildItem $ \mid $ Where-Object \{\$\_.Attributes -ne "Directory" -and \$\_.Extension -eq ".txt"\}}
		\item \question{Zaznacz prawidłowe komendy ustawiające aktualną lokalizację na „C:\textbackslash”:}%
		{Tak}{Set-Location c:\textbackslash}%
		{Tak}{chdir c:\textbackslash}%
		{Tak}{cd c\textbackslash}%
		{Nie}{goto c:\textbackslash}
		
		\newpage
		\item \question{Zaznacz wszystkie prawidłowe odpowiedzi opisujące Windows PowerShell (WPS):}%
		{Nie}{WPS to narzędzie open source do zarządzania systemami Windows spod konsoli linuxowej}%
		{Tak}{WPS zapewnia dostęp do obiektów COM}%
		{Tak}{WPS to środowisko oparte na platformie .NET}%
		{Tak}{WPS to środowisko do automatyzowania zadań administracyjnych przy użyciu skryptów}
		\item \question{Polecenie\\dir -exclude *.zip -name -recurse -force}%
		{Tak}{Wyświetli nazwy wszystkich plików znajdujących się w danym katalogu, wraz z plikami ze wszystkich podfolderów i ich podfolderów, wraz z plikami ukrytymi i bez dostępu do nich, bez plików z rozszerzeniem zip}%
		{Nie}{Wyświetli nazwy wszystkich plików, z pominięciem plików z rozszerzeniem zip, znajdujących się tylko w danym katalogu, wraz z plikami ukrytymi i bez dostępu do nich.}%
		{Nie}{Wyświetli nazwy wszystkich plików znajdujących się tylko w danym katalogu, wraz z plikami ukrytymi i bez dostępu do nich.}%
		{Nie}{Wyświetli nazwy wszystkich plików z rozszerzeniem zip znajdujących się w danym katalogu, wraz ze wszystkimi podfolderami, wraz z plikami ukrytymi i bez dostępu do nich.}
		\item \question{Wskaż polecenia działające w powłoce bash oraz powershell}%
		{Tak}{man}%
		{Tak}{cp}%
		{Tak}{cd}%
		{Nie}{gps}
		\item \question{Zmienne w interpreterze PowerShell:}%
		{Tak}{nie muszą być deklarowane}%
		{Nie}{wymagają określenia typu}%
		{Tak}{mogą mieć różne typy}%
		{Tak}{są obiektami .NET}
		\item \question{Polecenie PoweShell:\\„PS$ > $ get-process a* $ \mid $ stop-process”}%
		{Nie}{Dotyczy wszystkich procesów (a* = all)}%
		{Nie}{Jest poleceniem błędnym – nie wykona się}%
		{Tak}{Zatrzyma procesy, których lista jest pobierana za pomocą polecenia get-process a*}%
		{Tak}{Dotyczy tylko procesów, których nazwa zaczyna się na literę „a”}
		\item \question{W interpreterze PowerShell polecenie Get-Process:}%
		{Tak}{Pozwala wypisać wszystkie aktualnie uruchomione procesy}%
		{Nie}{Pozwala zmieniać priorytet procesu}%
		{Nie}{Pozwala zmieniać właściciela procesu na aktualnie zalogowanego użytkownika}%
		{Nie}{Przekierowywuje wynik działania procesu (standardowe wyjście) do pliku}
		
		\newpage
		\item \question{Interpreter Windows PowerShell:}%
		{Nie}{w systemie Windows 7 (lub Windows Server 2008) wymaga wcześniejszej instalacji}%
		{Tak}{Jest zintegrowany z .NET Framework}%
		{Tak}{Dostarcza środowisko do wykonywania zadań administracyjnych wykonywanych poleceniami cmdlets}%
		{Tak}{Wynikiem polecenia w interpreterze jest ciąg obiektów określonego typu}
		\item \question{Zanzacz wszystkie prawidłowe sformułowania dotyczące powłoki PowerShell:}%
		{Tak}{Dzięki operatorowi $ \mid $ (tzw. pipe) można przekierować wyjście jednego polecenia na wejście drugiego, np. get-process $ \mid $ stop-process}%
		{Tak}{Wszystkie zmienne są obiektami .NET}%
		{Nie}{Skrypty pisane dla linuksowego interpretera Bash mogą być uruchamiane w interpreterze PowerShell}%
		{Nie}{Polecenia PowerShell mają ściśle określone nazwy, do których nie można tworzyć aliasów.}
		\item \question{Które z poniższych par słów przedstawiają pewien cmdlet oraz jego alias w Windows PowerShell?}%
		{Tak}{Set-Location, cd}%
		{Tak}{Get-Help, man}%
		{Nie}{Remove-File, rm}%
		{Tak}{Remove-Item, del}
		\item \question{Liczby od 1 do 5 wypisze następujący skrypt:}%
		{Tak}{\$i = 1\\
			do \{\\
				Write-Host \$i\\
				\$i++\\
			\}\\
			while (\$i -le 5)}%
		{Tak}{\$i = 1\\
			do \{\\
				echo \$i\\
				\$i++\\
			\}\\
			while (\$i -le 5)}%
		{Nie}{\$i = 1\\
			do \{\\
				echo i\\
				i++\\
			\}\\
			while (\$i -le 5)}%
		{Nie}{\$i = 1\\
			do \{\\
				print \$i\\
				i++\\
			\}\\
			while (\$i -le 5)}
		
		\newpage
		\item \question{Które polecenia są poprawne i wyświetlają, posortowaną wg. pewnej kolumny, zawartośd bieżącego katalogu?}%
		{Tak}{ls $ \mid $ Sort-Object Name}%
		{Nie}{ls $ \mid $ Sort-Name}%
		{Tak}{ls $ \mid $ Sort-Object Length}%
		{Nie}{ls $ \mid $ Sort(Length)}
		\item \question{Polecenie:\\"get-childitem C:\textbackslash* -include *.txt"\\wydane w Windows PowerShell:}%
		{Tak}{wyświetli nazwy wszystkich plików o rozszerzeniu ".txt" znajdujących się w ścieżce C:\textbackslash}%
		{Nie}{wyświetli nazwy wszystkich plików o rozszerzeniu ".txt" znajdujących się w ścieżce C:\textbackslash i jej podkatalogach}%
		{Nie}{wyświetli tylko nazwy wszystkich plików o rozszerzeniu ".txt" znajdujących się w ścieżce C:\textbackslash}%
		{Tak}{wyświetli m.in. nazwę i czas ostatniego czas ostatniego zapisu wszystkich plików o rozszerzeniu ".txt" znajdujących się w ścieżce C:\textbackslash}
		\item \question{Która z wersji systemu Windows obsługuje interpreter Windows PowerShell?}%
		{Nie}{Windows 98}%
		{Tak}{Windows XP}%
		{Tak}{Windows Vista}%
		{Tak}{Windows 7}
		\item \question{PS E:\textbackslash test$ > $ ls\\
			Directory: E:\textbackslash test\\
			Mode   LastWriteTime Length Name\\
			$ ----\;\;\;\;\;\;-------------\;\;\;------\;\;\;---- $\\
			$ -a--- $  2012-06-02    16:12  0 a.xyz\\
			$ -a--- $  2012-06-02    16:12  0 b.xyz\\
			$ -a--- $  2012-06-02    16:12  0 c.xyz\\
			$ -a--- $  2012-06-02    16:12  0 d.xyy\\
			$ -a--- $  2012-06-02    16:12  0 e.xxy\\
			PS E:\textbackslash test$ > $ get-childitem C:\textbackslash test\textbackslash * -include *.xyz -recurse $ \mid $ remove-item\\
			Zaznacz możliwe do otrzymania wyniki działania komendy ls z dowolnymi parametrami po wykonaniu powyższej komendy:\\
			\textbf{(\emph{Zbieracz Forczu}: te kreski są przerywane, zwykłe myślniki)}}%
		{Tak}{Directory: E:\textbackslash test\\
			Mode  LastWriteTime Length Name\\
			----  ------------- ------ ----\\
			-a--- 2012-06-02    16:12  0 d.xyy\\
			-a--- 2012-06-02    16:12  0 e.xyy}%
		{Tak}{Directory: E:\textbackslash test\\
			Mode  LastWriteTime Length Name\\
			----  ------------- ------ ----\\
			-a--- 2012-06-02    16:12  0 e.xxy}%
		{Tak}{d.xyy\\
			e.xxy\\
			PS E:\textbackslash test$ > $}%
		{Tak}{Directory: E:\textbackslash test\textbackslash }
		
		\newpage
		\item \question{Zdania prawdziwe, opisujące zmienne PowerShell, to:}%
		{Nie}{Zmienne muszą mieć zdefiniowany typ}%
		{Tak}{Wszystkie zmienne są obiektami .NET}%
		{Tak}{Nie muszą być deklarowane}%
		{Nie}{Wszystkie zmienne są globalne}
		\item \question{Które z podanych przykładów pętli są poprawne w PowerShell?}%
		{Tak}{foreach (\$i in get-childitem c:\textbackslash scripts) \{\$i.extension\}}%
		{Tak}{for(\$zm = 1; \$zm -le 10; \$zm++) \{\$zm\}}%
		{Nie}{for(a = 1; i $ < $ 10; ++i) \{i\}}%
		{Nie}{while(\$i -lt 10) \{\$i\}}
		\item \question{Które z przytoczonych niżej cech odnoszą się do powłoki PowerShell?}%
		{Nie}{Korzystanie z pętli for, while i until jest niedozwolone.}%
		{Tak}{Odwoływanie się do zmiennych jest możliwa poprzez użycie znaku \$}%
		{Nie}{Zmienne nie mogą mieć zakresów widoczności}%
		{Tak}{Wszystkie zmienne są obiektami .NET}
		\item \question{Które polecenie powłoki PowerShell wyświetli listę uruchomionych usług?}%
		{Tak}{Get-Service $ \mid $ Where-Object \{\$\_.name -eq "running"\}}%
		{Nie}{Get-Service $ \mid $ Where-Object \{\$\_.name -eq "SysMain"\}}%
		{Nie}{Get-Service $ \mid $ Where-Object \{\$\_.name -eq "stopped"\}}%
		{Nie}{Get-Process $ \mid $ Where-Object \{\$\_.name -eq "running"\}}
		\item \question{Aliasami polecenia Set-Location w Windows Powershell są:}%
		{Tak}{sl}%
		{Tak}{cd}%
		{Tak}{chdir}%
		{Nie}{setloc}
		\item \question{\$a = 5\\
			If (\$a -eq 5)\\
			\{”Piątka ”\}\\
			elseif (\$a -lt 6)\\
			\{”mniejsza od szóstki”\}\\
			If (\$a -gt 3)\\
			\{”większa od trójki”\}\\
			Po wykonaniu tego kodu w oknie Windows Powershell:}%
		{Nie}{Zostanie wypisany tekst „Piątka mniejsza od szóstki”}%
		{Nie}{Zostanie wypisany tekst „Piątka mniejsza od szóstki większa od trójki”}%
		{Tak}{Zostanie wypisany tekst „Piątka większa od trójki”}%
		{Nie}{Zostanie wypisany komunikat o błędzie w kodzie programu}
		
		\newpage
		\item \question{Które z wymienionych opisów dotyczy PowerShella:}%
		{Tak}{ułatwia zadania administracyjne}%
		{Nie}{jest zgodny linuksową powłoką shell}%
		{Nie}{może być wykorzystywany tylko przez administratorów}%
		{Tak}{może być wykorzystywany przez wszystkich użytkowników}
		\item \question{Wskaż prawdziwe zdania. Zdania dotyczą polityki uruchamiania skryptów w konsoli PowerShell.}%
		{Tak}{Polityka Unrestricted umożliwia uruchamianie niepodpisanych skryptów.}%
		{Nie}{Polityka Restricted umożliwia uruchomienie tylko tych skryptów, które pochodzą z lokalnego komputera.}%
		{Nie}{Polityka AllSigned jest polityką domyślną.}%
		{Tak}{Polityka AllSigned umożliwia uruchamianie skryptów które zostały podpisane przez zaufanego wydawcę lub pochodzą z komputera lokalnego.}
		\item \question{Wskaż prawdziwe zdania. Zdania dotyczą uruchamiania skryptów w konsoli PowerShell.}%
		{Tak}{W konsoli PowerShell nie jest możliwe uruchomienie skryptu bez podania jego pełnej ścieżki.}%
		{Nie}{W konsoli PowerShell jest możliwe uruchomienie skryptu bez podania jego pełnej ścieżki, jednak wymaga to ustawienia odpowiedniej polityki uruchamiania skryptów.}%
		{Nie}{W konsoli PowerShell jest możliwe uruchomienie jakiegokolwiek skryptu bez podania jego pełnej ścieżki pod warunkiem, że bieżącą ścieżką będzie folder zawierający skrypt oraz polityka uruchamiania skryptów jest ustawiona na Unrestricted.}%
		{Nie}{W konsoli PowerShell jest możliwe uruchomienie skryptu bez podawania jego pełnej ścieżki w przypadku gdy skrypt ten pochodzi z komputera lokalnego.}
		\item \question{Windows PowerShell:}%
		{Tak}{Jest zintegrowany z .NET Framework}%
		{Nie}{Dostępny jest dla systemu Windows 2000}%
		{Tak}{Jest interpreterem poleceń}%
		{Nie}{Zwraca w wyniku każdego polecenia zmienną typu string}
		\item \question{Polecenie:\\"get-childitem C:\textbackslash Kolokwium\textbackslash Main\textbackslash * -include *.kol -recurse $ \mid $ remove-item"\\w Windows PowerShell:}%
		{Tak}{Znajduje i usuwa wszystkie pliki z rozszerzeniem "kol" z folderu "C:\textbackslash Kolokwium\textbackslash Main" i jego podfolderów}%
		{Nie}{Znajduje i usuwa wszystkie pliki z rozszerzeniem "kol" z folderu nadrzędnego do "C:\textbackslash Kolokwium\textbackslash Main", tzn. "C:\textbackslash Kolokwium"}%
		{Nie}{Znajduje i usuwa wszystkie pliki z rozszerzeniem "kol" wyłącznie z folderu "C:\textbackslash Kolokwium\textbackslash Main"}%
		{Nie}{Żadna z odpowiedzi nie jest prawidłowa}
		
		\newpage
		\item \question{Wskaż poprawne zdania dotyczące zmiennych w Windows PowerShell:}%
		{Tak}{Wszystkie zmienne są obiektami .NET.}%
		{Nie}{Zmienne muszą mieć nadany typ.}%
		{Nie}{Wartość do zmiennej przypisuje operator „:=”}%
		{Tak}{Zmienne mogą mieć zakres widoczności.}
		\item \question{Które z poniższych skryptów PowerShella wydrukują listę nazw wszystkich plików o rozszerzeniu .txt w aktualnie wybranym katalogu?}%
		{Tak}{get-childitem $ \mid $ where-object \{\$\_.extension -eq ".txt"\} $ \mid $ format-table Name}%
		{Nie}{get-childitem $ \mid $ format-table Name $ \mid $ where-object \{\$\_.extension -eq ".txt"\}}%
		{Tak}{foreach(\$a in get-childitem) \{\\
				if(\$a.extension -eq ".txt") \{\\
					\$a.Name\\
				\}\\
			\}}%
		{Tak}{get-childitem $ \mid $ foreach \{if(\$\_.extension -eq ".txt")\{\$\_.Name\}\}}
		\item \question{Zamiennikiem poleceo dir i ls w PowerShell jest polecenie:}%
		{Tak}{Get-ChildItem}%
		{Nie}{Get-Content}%
		{Nie}{Tee-Object}%
		{Nie}{Set-Variable}
		\item \question{Co charakteryzuje PowerShell:}%
		{Tak}{Nie rozróżnia wielkości liter w komendach}%
		{Nie}{Każdą linię w pliku .ps należy zakończyć średnikiem}%
		{Tak}{Zmienne oznacza się znakiem dolara '\$'}%
		{Tak}{Istnieje różnica między pojedynczym a podwójnym cudzysłowem}
		\item \question{Które zdania o PowerShel są FAŁSZYWE:}%
		{Nie}{jest zintegrowany z .NET Framework}%
		{Tak}{GetChildItem zwraca wszystkie obiekty jakie zawierają dzieci bieżącej lokalizacji}%
		{Nie}{Zmienne są obiektami}%
		{Tak}{Do zmiennych odwołujemy się znakiem \%}
		\item \question{Instrukcja w PowerShel która zatrzymuje (ang.kill) procesy zaczynające się na literę Y to:}%
		{Tak}{get-process Y* $ \mid $ stop-process}%
		{Nie}{get-process Y* $ \mid $ kill-proces}%
		{Tak}{ps Y* $ \mid $ stop-process}%
		{Tak}{ps Y* $ \mid $ kill-process}
		
		\newpage
		\item \question{Użytkownik korzysta z Powershella w środowisku Windows i znajduje się w lokalizacji C:\textbackslash MyScripts$ > $ po wywołaniu komendy ls, okazało się, że w tym folderze znajduje się plik script.ps1. Użytkownik zamierzając go uruchomić, zmienił aktualna politykę wykonywania skryptów z Restricted na RemoteSigned. Które z poniższych komend uruchomią w/w skrypt?}%
		{Nie}{run script.ps1}%
		{Nie}{script.ps1}%
		{Tak}{C:\textbackslash MyScripts\textbackslash script.ps1}%
		{Tak}{.\textbackslash script.ps1}
		\item \question{Co się stanie po wywołaniu komendy:\\get-process pow* $ \mid $ stop-process}%
		{Tak}{Zostaną zatrzymane wszystkie procesy, których nazwa zaczyna się od ciągu znaków "pow"}%
		{Tak}{Powershell zostanie wyłączony}%
		{Nie}{Zostaną zatrzymane wszystkie procesy, których nazwa zawiera ciąg znaków "pow"}%
		{Nie}{Nic się nie stanie}
		\item \question{Wskaż poprawne polecenia PowerShell usuwające z bieżącego katalogu pliki większe niż 2kB:}%
		{Tak}{Get-Childitem $ \mid $ Where-Object \{ \$\_.length -gt 2kB \} $ \mid $ Remove-Item}%
		{Nie}{Get-Childitem $ \mid $ Where-Object ( \$\_.length $ > $ 2kB ) $ \mid $ Remove-Item}%
		{Nie}{Get-Childitem $ \mid $ Remove-Item $ \mid $ Where (\$length $ > $ 2kB)}%
		{Tak}{ls $ \mid $ where-object \{ \$\_.length -gt 2kB \} $ \mid $ rm}
		\item \question{Po wykonaniu w konsoli PowerShell polecenia Get-ExecutionPolicy otrzymano rezultat "Restricted". Oznacza to, że użytkownik:}%
		{Tak}{Nie może uruchamiać żadnych skryptów, a jedynie osobne komendy}%
		{Nie}{Może uruchamiać niepodpisane skrypty pochodzące z lokalnego komputera}%
		{Nie}{Może uruchamiać podpisane skrypty pobrane z Internetu}%
		{Nie}{Może uruchamiać niepodpisane skrypty pobrane z Internetu}
		\item \question{W PowerShell polecenie Get-Process:}%
		{Tak}{Wylistuje wszystkie aktualnie uruchomione procesy}%
		{Nie}{Zmieni priorytet procesu}%
		{Nie}{Zmieni właściciela procesu na aktualnie zalogowanego użytkownika}%
		{Nie}{Przekierowuje wynik działania procesu (standardowe wyjście) do pliku}
		\item \question{W PowerShell polityka bezpieczeostwa RemoteSigned zezwala na:}%
		{Nie}{Wykonywanie dowolnych skryptów.}%
		{Tak}{Uruchamianie skryptów podpisanych przez zaufanego wydawcę.}%
		{Tak}{Uruchamianie niepodpisanych skryptów, które powstały na lokalnym komputerze.}%
		{Nie}{Korzystanie jedynie z pojedynczych komend, bez możliwości uruchamiania skryptów.}
		
		\newpage
		\item \question{Prawidłowa postać pętli for w PowerShell to:}%
		{Nie}{for (i = 1, i -le 10, i++) \{ \}}%
		{Nie}{for (i = 1; i -le 10; i++) \{ \}}%
		{Nie}{for (\$i = 1; \$i $ < $= 10; i++) \{ \}}%
		{Tak}{for (\$i = 1; \$i -le 10; \$i++) \{ \}}
		\item \question{Jaki jest rezultat polecenia interpretera PowerShell:\\
			get-childitem C:\textbackslash Work\textbackslash -recurse $ \mid $ get-acl $ \mid $ where \{ \$\_.Owner -match "Maniek"\}}%
		{Tak}{Wypisze wszystkie pliki, których właścicielem jest Maniek z folderu C:\textbackslash Work oraz podfolderów}%
		{Nie}{Wypisze tylko pliki z folderu C:\textbackslash Work, których właścicielem jest Maniek.}%
		{Nie}{Wypisze wszystkie pliki z dysku C:, których właścicielem jest Maniek.}%
		{Nie}{Wypisze pliki, które nie należą do użytkownika Maniek, z folderu C:\textbackslash Work}
		\item \question{Co otrzymamy po wykonaniu następującej komendy w interpreterze PowerShell:\\
			PS C:\textbackslash $ > $ Get-ChildItem $ \mid $ where \{ !\$\_.PslsContainer  \} $ \mid $ Select-Object Name}%
		{Nie}{Tylko nazwy folderów jakie znajdują się w lokalizacji C:\textbackslash}%
		{Nie}{Tylko nazwy folderów i podfolderów jakie znajdują się w lokalizacji C:\textbackslash}%
		{Tak}{Tylko nazwy plików jakie znajdują się w lokalizacji C:\textbackslash}%
		{Nie}{Dokładny opis folderów, czyli m.in. nazwy i uprawnienia jakie znajdują się w lokalizacji C:\textbackslash}
		
		%\item \question{}%
		%{Tak}{}%
		%{Nie}{}%
		%{}{}%
		%{}{}
		
	\end{enumerate}